/****************************
 * Build Environment Setup
 ****************************/
apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'application'

def localServerRepoURL = "file://${projectDir}/../build/repo"

/****************************
 * Project Descriptors
 ****************************/
group = 'wa.arm.springselector.ws'
version = '1.0-SNAPSHOT'

description = "Workshop Automation: Workshop Arm: Spring selection service: Web Service"
mainClassName = 'wa.arm.springselector.ws.WebServerMoxy'

// Make sure gradle run takes user input (the app is designed to terminate on key press)
run{
	standardInput = System.in
}

sourceCompatibility = 1.8
targetCompatibility = 1.8


/****************************
 * Project Output
 ****************************/
jar {
    manifest {
        attributes 'Main-Class': 'wa.arm.springselector.ws.WebServerMoxy'
    }
}

/****************************
 * Project File Structure
 ****************************/
configurations {
	data ( transitive = false }
}

/* 
Note: Useful reference for integration test addition: 
  https://spin.atomicobject.com/2018/07/18/gradle-integration-tests/
*/
// By default, src/main and src/test are set up correctly
sourceSets {
    // Add integration tests
    intTest {
        // Note: configuration.testCompile includes (unit) testCompile dependencies in compilation of integration tests 
        compileClasspath += sourceSets.main.output + configurations.testCompile
        runtimeClasspath += output + compileClasspath + configurations.testRuntime
    }
}

/****************************
 * Project Dependencies
 ****************************/
dependencies {
    // Core logic
    compile "wa.arm.springselector:core:1.0-SNAPSHOT"

    // Web Server
    compile "org.glassfish.jersey.containers:jersey-container-grizzly2-http:2.27"
    // Web Services annotations etc.
    compile "org.glassfish.jersey.inject:jersey-hk2:2.27"
    // Provide JSON support
    compile "org.glassfish.jersey.media:jersey-media-moxy:2.27"
    
    // Unit testing dependencies
    testCompile 'junit:junit:4.12'
    // Test helpers
    testCompile group: 'org.glassfish.jersey.test-framework.providers', name: 'jersey-test-framework-provider-bundle', version:'2.27'
    // Integration testing dependencies
    intTestImplementation 'junit:junit:4.12'
    
    // Data dependencies
    data 'wa.arm.springselector:data:1.0-SNAPSHOT'    
}

// Library repositories
repositories {
    maven {
        url localServerRepoURL
    }
    jcenter()
    mavenCentral()
}

task untarData(type: Copy) {
	/* The data TAR ball contains the Springs.csv database this app uses. However, to
	use it in HSQL the file itself needs to be accessible on disk and not buried in
	an archive. At runtime this will therefore be invoked to untar the springs.csv
	into the data subdirectory of the project */
	from tarTree(configurations.data.singleFile) matching {
		include "springs.csv"
	}
	into "${projectDir}/data/"
}
run.dependsOn untarData

/****************************
 * Process Additions
 ****************************/
// Adding additional configuration for integration testing
configurations {
    intTestImplementation.extendsFrom implementation
    intTestRuntimeOnly.extendsFrom runtimeOnly
}

// Integration test task
task integrationTest(type: Test) {
    description = 'Runs integration tests.'
    group = 'verification'

    testClassesDirs = sourceSets.intTest.output.classesDirs
    classpath = sourceSets.intTest.runtimeClasspath
    /* Forces Gradle to always run the integration tests when asked to. 
    By default, Gradle attempts to optimize task execution by not re-running 
    tasks whose inputs have not changed. Since integration tests may fail 
    due to external systems, we want to run them even if no code has changed. */
    outputs.upToDateWhen { false }
    shouldRunAfter test
}

// Adds integration tests to the "check" task list 
check.dependsOn integrationTest

